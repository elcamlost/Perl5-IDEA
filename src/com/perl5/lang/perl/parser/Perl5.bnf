{
  parserClass="com.perl5.lang.perl.parser.PerlParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

//  generate=[tokens="yes" psi="yes" tokenAccessors="yes"]

  psiClassPrefix="Perl"
  psiImplClassSuffix="Impl"
  psiPackage="com.perl5.lang.perl.psi"
  psiImplPackage="com.perl5.lang.perl.psi.impl"

  elementTypeHolderClass="com.perl5.lang.perl.lexer.PerlElementTypes"
  elementTypeClass="com.perl5.lang.perl.PerlElementType"
  tokenTypeClass="com.perl5.lang.perl.PerlTokenType"

  parserUtilClass="com.perl5.lang.perl.parser.PerlParserUitl"
  psiImplUtilClass="com.perl5.lang.perl.psi.impl.PerlPsiImpUtil"

  //elementTypeFactory="com.perl5.lang.perl.psi.PerlElementFactory.getCompositeType"
//  tokenTypeFactory="com.perl5.lang.perl.psi.PerlElementFactory.getCompositeType"

  tokens=[
    PERL_COMMENT="PERL_COMMENT"
    PERL_COMMENT_BLOCK="PERL_COMMENT_BLOCK"
    PERL_POD="PERL_POD"

    PERL_SIGIL_ARRAY="@"
    PERL_SIGIL_HASH="%"
    PERL_SIGIL_SCALAR="$"
    PERL_SIGIL_SCALAR_INDEX="$#"

    PERL_STRING_MULTILINE="PERL_STRING_MULTILINE" // should be string content too
    PERL_STRING_MULTILINE_END="PERL_STRING_MULTILINE_END"

    PERL_VERSION="PERL_VERSION"
    PERL_NUMBER_VERSION="PERL_NUMBER_VERSION"
    PERL_NUMBER="PERL_NUMBER"

    PERL_KEYWORD="PERL_KEYWORD"

    PERL_OPERATOR="PERL_OPERATOR"
    PERL_OPERATOR_UNARY="PERL_OPERATOR_UNARY"
    PERL_OPERATOR_FILETEST="PERL_OPERATOR_FILETEST"

    PERL_REGEX_QUOTE="PERL_REGEX_QUOTE"
    PERL_REGEX_MODIFIER="PERL_REGEX_MODIFIER"
    PERL_REGEX_TOKEN="PERL_REGEX_TOKEN"

    PERL_STRING="PERL_STRING"
    PERL_STRING_CONTENT="PERL_STRING_CONTENT"

    PERL_BAREWORD="PERL_BAREWORD"
    PERL_TAG="PERL_TAG"

    PERL_COMMA=','
    PERL_ARROW_COMMA='=>'
    PERL_DEREFERENCE='->'
    PERL_DEPACKAGE='::'
    PERL_COLON=":"
    PERL_LBRACK='['
    PERL_RBRACK=']'
    PERL_LPAREN='('
    PERL_RPAREN=')'
    PERL_LBRACE='{'
    PERL_RBRACE='}'
    PERL_LANGLE='<'
    PERL_RANGLE='>'
    PERL_SEMI=';';
    PERL_QUOTE="\""

    // custom tokens
    PERL_PACKAGE="PERL_PACKAGE"
    PERL_FUNCTION="PERL_FUNCTION"
    PERL_HANDLE="PERL_HANDLE"
    PERL_BLOCK_NAME="PERL_BLOCK_NAME"
  ]

    extends(".*expr")=expr
 }

///////////////////////////// main code structure //////////////////////////////////////////////////////////////////////
private perlFile ::= <<parseFile>> <<eof>>

private file_items ::= file_item*

private block_safe ::= <<parseBlock>>
block ::= "{" file_items "}"  // should not be used anywhere, injected by block_safe

private file_item ::= namespace | namespace_element
private namespace_element ::= (sub_definition | named_block | compound_statement | statement <<statementSemi>> ) PERL_SEMI*

// package keyword
namespace ::= 'package' <<parsePerlPackage>> {pin=1}
private namespace_content ::= namespace_element * // injected and wrapped by parsePackageContents

named_block ::= PERL_BLOCK_NAME block_safe

// declarations
private compound_statement ::=
    [label_declaration] (
        block_compound
        | if_compound
        | unless_compound
        | given_compound
        | while_compound
        | until_compound
        | for_compound
        | foreach_compound
     )

if_compound ::= 'if' compound_conditional_block if_compound_elsif * [if_compound_else]
unless_compound ::= 'unless' compound_conditional_block if_compound_elsif * [if_compound_else]
private if_compound_elsif ::= 'elsif' compound_conditional_block
private if_compound_else  ::= 'else' block_safe

private compound_conditional_block ::= paren_expr_term block_safe

given_compound ::= 'given' compound_conditional_block

while_compound ::= 'while' compound_conditional_block [compound_continue_block]
until_compound ::= 'until' compound_conditional_block [compound_continue_block]

private compound_continue_block ::= 'continue' block_safe

block_compound ::= block_safe [compound_continue_block]


// for/foreach
for_compound ::= 'for' for_compound_arguments
foreach_compound ::= 'foreach' for_compound_arguments
private for_compound_arguments ::= for_compound_arguments_iteration | for_compound_arguments_list

private for_compound_arguments_iteration ::=  for_compound_arguments_iteration_arguments block_safe
private for_compound_arguments_iteration_arguments ::= '(' [expr]  PERL_SEMI [expr] PERL_SEMI [expr] ')' {pin=1}

// @todo only single variable or variable definition may be here
private for_compound_arguments_list ::=
    [ variable_declaration | variable ] paren_expr_term block_compound

private statement ::= statement_variation [statement_modifier] {recoverWhile=recover_statement}

private statement_variation ::=
    use_statement
    | no_statement
    | sub_declaration
    | expr

sub_definition ::= 'sub' <<parseSubDefinition>>

private sub_definition_parameters ::=
    sub_prototype [sub_attributes]
    | sub_attributes [sub_signature]
    | sub_signature

sub_declaration ::= 'sub' <<parseSubDeclaration>>

private sub_declaration_parameters ::=  [sub_prototype] [sub_attributes]

private sub_prototype ::= "(" [<<parseSubPrototype>>] ")" {pin=1}
private sub_signature ::= "(" [<<parseSubSignature>>] ")" {pin=1}
private sub_attributes ::= ":" <<parseSubAttributes>> {pin=1}

//private recover_attributes ::= !(" (" | PERL_LBRACE)

last_term ::= 'last' [lnr_param]
next_term ::= 'next' [lnr_param]
redo_term ::= 'redo' [lnr_param]
private lnr_param ::= label | expr


private statement_modifier ::=
    if_statement_modifier
    | unless_statement_modifier
    | while_statement_modifier
    | until_statement_modifier
    | for_statement_modifier
    | foreach_statement_modifier
    | when_statement_modifier

if_statement_modifier ::= 'if' expr {pin=1}
unless_statement_modifier ::=  'unless' expr {pin=1}
while_statement_modifier ::=  'while' expr {pin=1}
until_statement_modifier ::=  'until' expr {pin=1}
for_statement_modifier ::=  'for' expr  {pin=1}   // actually @LIST
foreach_statement_modifier ::=  'foreach' expr {pin=1} // actually @LIST
when_statement_modifier ::= 'when' expr {pin=1}

use_statement ::= 'use' <<parseUseStatement>> {pin=1}
no_statement ::= 'no' <<parseNoStatement>> {pin=1}


private recover_statement ::= !(PERL_SEMI  | <<eof>>)
private recover_paren ::= !(PERL_RPAREN | <<eof>>)
private recover_angle ::= !(PERL_RANGLE | <<eof>>)
private recover_brace ::= !(PERL_RBRACE | <<eof>>)
private recover_brack ::= !(PERL_RBRACK | <<eof>>)

// expression
expr ::=
    lp_or_xor_expr
    | lp_and_expr
    | lp_not_expr
    | rightward_call_expr
    | comma_expr
    | assign_expr
    | trenar_expr
    | flipflop_expr
    | or_expr
    | and_expr
    | bitwise_or_xor_expr
    | bitwise_and_expr
    | equal_expr
    | compare_expr
    | op_10_expr
    | shift_expr
    | add_expr
    | mul_expr
    | regex_expr
    | op_5_expr
    | pow_expr
    | op_3_expr
    | deref_expr
    | term_expr

term_expr ::=
    variable
    | variable_declaration
    | PERL_OPERATOR_UNARY paren_expr_term // named operators as functions
    | paren_expr_term
    | scalar_primitive
    | do_term
    | sub_term
    | eval_term
    | regex_term
    | file_read_term
    | reference_value
    | print_term
    | open_term
    | close_term
    | grep_term
    | sort_term
    | map_term
    | require_term
    | undef_term
    | last_term
    | next_term
    | redo_term
    | function_call

private paren_expr_term ::= "(" [expr] ")" {pin=1}
private brack_expr_term ::= "[" [expr] "]" {pin=1}
private brace_expr_term ::= "{" [expr] "}" {pin=1}

deref_expr ::= expr <<parseArrowSmart>> nested_element_expr

private op_3_expr ::= pref_pp_expr | suff_pp_expr
pref_pp_expr ::= ('++'|'--') expr
suff_pp_expr ::= expr ('++'|'--')

pow_expr ::= expr ('**' expr)+ { rightAssociative=true }

private op_5_expr ::= ref_expr | bareword_expr| prefix_unary_expr
ref_expr ::= '\' expr { rightAssociative=true }
bareword_expr ::= <<parseBarewordStringMinus>>
prefix_unary_expr ::= ('~'| '!'| '+' | '-') expr { rightAssociative=true }

regex_expr ::= expr ('=~'|'!~') expr
mul_expr ::= expr ('*'|'/'|'%'|'x') expr
add_expr ::= expr ('+'|'-'|'.') expr
shift_expr ::= expr ('<<'|'>>') expr

private op_10_expr ::= named_unary_expr | filetest_expr
named_unary_expr ::= PERL_OPERATOR_UNARY !"(" expr
filetest_expr ::= PERL_OPERATOR_FILETEST (<<parseBarewordHandle>> | expr )

compare_expr ::= expr ('>='|'<='|'<'|'>'|'lt'|'gt'|'le'|'ge') expr
equal_expr ::= expr ('=='|'!='|'<=>'|'eq'|'ne'|'cmp'|'~~') expr
bitwise_and_expr ::= expr '&' expr
bitwise_or_xor_expr ::= expr ('|'|'^') expr
and_expr ::= expr '&&' expr
or_expr ::= expr ('||'|'//') expr
flipflop_expr ::= expr ('..'|'...') expr
trenar_expr ::= expr '?' expr ':' expr { rightAssociative=true }
assign_expr ::= expr ('=' | '**='|'+='|'-='| '*='|'/='|'x='| '&='|'|='|'.='| '<<='|'>>='|'%='| '&&='|'||='|'^='| '//=') expr { rightAssociative=true }

comma_expr ::= expr (','|'=>') [scalar_expr]

rightward_call_expr ::= callable <<parseRightwardCallParameters>>
lp_not_expr ::= 'not' expr { rightAssociative=true }
lp_and_expr ::= expr 'and' expr
lp_or_xor_expr ::= expr ('or'|'xor') expr

private scalar_expr ::= <<parseExpressionLevel 4>>

print_term ::= ("print"|"say") ( "(" [print_arguments] ")" | [print_arguments] )
undef_term ::= "undef" variable

require_term ::= 'require' (perl_package | perl_version | string)  // @todo multiline string is possible too

private print_arguments ::= perl_handle expr | expr

open_term ::= "open" ( "(" open_arguments ")" | open_arguments )
private open_arguments ::=
    open_handle [                       // open FILEHANDLE
        "," (
            open_mode "," (
                open_ref                // open FILEHANDLE,MODE,REFERENCE
                | open_file ["," expr]  // open FILEHANDLE,MODE,EXPR,LIST ?
            )
            | open_file                 // open FILEHANDLE,EXPR
        )
    ]
open_handle ::= variable_declaration | perl_handle
open_mode ::= scalar_expr
open_ref ::= ref_expr
open_file ::= perl_handle | scalar_expr

close_term ::= "close" ( "(" close_arguments ")" | close_arguments )
private close_arguments ::= perl_handle

sort_term ::= 'sort' sort_op_arguments
private sort_op_arguments ::=
    <<parseBarewordFunction>> expr
    | block_safe expr
    | expr

sub_term ::= 'sub' sub_definition_parameters block_safe

grep_term ::= 'grep' grep_map_arguments
map_term ::= 'map' grep_map_arguments
private grep_map_arguments ::=
    "(" grep_map_arguments_variations ")"
    | grep_map_arguments_variations

private grep_map_arguments_variations ::=
    block_safe expr
    | scalar_expr "," expr

private function_call ::= callable paren_expr_term

file_read_term ::= '<' [perl_handle] '>'

////////////////////////// regular expressions /////////////////////////////////////////////////////////////////////////
private regex_term ::=
    compile_regex
    | replacement_regex
    | tr_regex
    | match_regex

compile_regex ::= 'qr' match_regex_body
match_regex ::= ['m'] match_regex_body
private match_regex_body ::= PERL_REGEX_QUOTE [perl_regex] PERL_REGEX_QUOTE [perl_regex_modifiers]
replacement_regex ::= 's' PERL_REGEX_QUOTE [perl_regex] PERL_REGEX_QUOTE regex_replacement [perl_regex_modifiers]

private regex_replacement ::=
    PERL_REGEX_QUOTE [perl_regex] PERL_REGEX_QUOTE
    | [perl_regex] PERL_REGEX_QUOTE

perl_regex_modifiers ::= PERL_REGEX_MODIFIER +
perl_regex ::= PERL_REGEX_TOKEN + // here we should make a trick

tr_regex ::= ('tr'|'y') PERL_REGEX_QUOTE tr_searchlist PERL_REGEX_QUOTE [PERL_REGEX_QUOTE] tr_replacementlist PERL_REGEX_QUOTE [tr_modifiers]
tr_searchlist ::= PERL_STRING_CONTENT
tr_replacementlist ::= PERL_STRING_CONTENT

tr_modifiers ::= PERL_REGEX_MODIFIER +
////////////////////////// end of regular expressions //////////////////////////////////////////////////////////////////

do_term ::= "do" block_safe
eval_term ::= "eval" block_safe

private variable_declaration ::=
    variable_declaration_global
    | variable_declaration_lexical
    | variable_declaration_local

// @todo attributes support
// @todo local variables supports hash/aray elements
variable_declaration_local ::= 'local' [perl_package]  variable_definition_variation {pin=1}
variable_declaration_lexical ::= ('my' | 'state') [perl_package] variable_definition_variation {pin=1}
variable_declaration_global ::= 'our' [perl_package] variable_definition_variation {pin=1}

private variable_definition_variation ::= variable_definition_paren | variable
private variable_definition_paren ::= '(' variable (',' variable ) * ')' {pin=1}

/////////////////////////////////// REFERENCES /////////////////////////////////////////////////////////////////////////
// most of the references created by \ operator, but some - don't
reference_value ::=
    anon_array_ref
    | anon_hash_ref
    | code_ref
    | glob_item_ref

private anon_array_ref ::= brack_expr_term
private anon_hash_ref ::= brace_expr_term
private code_ref ::= "sub" block_safe
private glob_item_ref ::= perl_glob "{" glob_item_ref_variant "}" {pin=2}
private glob_item_ref_variant ::=
    "SCALAR"
    | "ARRAY"
    | "HASH"
    | "CODE"
    | "IO"
    | "GLOB"
    | "FORMAT"
    | "NAME"
    | "PACKAGE"

//////////////////////////// END OF REFERENCES /////////////////////////////////////////////////////////////////////////

private variable ::= scalar | array | hash | perl_glob

private array ::=
    array_primitive brack_expr_term              // array slice
    | array_primitive brace_expr_term              // hash slice
    | array_primitive

private hash ::=
    PERL_SIGIL_HASH brace_expr_term   // hash dereference w braces
    | PERL_SIGIL_HASH scalar_expr       // scalar dereference wo braces
    | perl_hash                    // hash as is

private scalar ::=
    perl_scalar nested_element    // hash or array item
    | perl_scalar
    | PERL_SIGIL_SCALAR "{" PERL_BAREWORD "}"
    | paren_expr_term nested_element
    | 'undef'

private nested_element ::=
    "{" PERL_BAREWORD  "}"
    | brack_expr_term
    | brace_expr_term

// extended nested element for using in ()
private nested_element_expr ::=
    nested_element
    | paren_expr_term    // function call like $var->()
    | scalar_call
    | function_call
    | rightward_call_expr

scalar_call ::= perl_scalar paren_expr_term

///////////////////////////////////// CALLABLE /////////////////////////////////////////////////////////////////////////

callable ::= <<resetLastCallable>> (
    referencable_method
    | <<guessBarewordCallable>>
)

private referencable_method ::= '&'
    (
        <<guessBarewordCallable>>
        | {expr}
        | scalar
    )

////////////////////////////////END OF CALLABLE ////////////////////////////////////////////////////////////////////////


// primitives
private scalar_primitive ::=
    PERL_NUMBER
    | PERL_TAG  // __PACKAGE__ etc.
    | string


private array_primitive ::=
    string_list
    | PERL_SIGIL_ARRAY '{' expr '}'   // scalar dereference
    | PERL_SIGIL_ARRAY scalar_expr       // scalar dereference
    | perl_array                    // array as is

string ::= string_quoted | multiline_marker | <<parseBarewordString>>
private string_quoted ::= ['qq' | 'qx' | 'q'] PERL_QUOTE <<parseBarewordString>> PERL_QUOTE
private multiline_marker ::= '<<' (string | <<parseBarewordString>>)

private string_list ::= 'qw' PERL_QUOTE <<parseBarewordString>> * PERL_QUOTE

label_declaration ::= label ":" // do we need to change tokentype?
label ::= PERL_BAREWORD
private perl_version ::= <<parseVersion>>
private perl_package ::= <<parseBarewordPackage>>
private perl_handle ::= <<parseBarewordHandle>> | perl_scalar !PERL_OPERATOR | "{" scalar "}"

// this is pretty raw
perl_scalar ::=
    (PERL_SIGIL_SCALAR_INDEX | PERL_SIGIL_SCALAR) PERL_SIGIL_SCALAR * PERL_BAREWORD ("::" PERL_BAREWORD) *
    | perl_scalar_built_in


private perl_scalar_built_in ::=
    "$^WARNING_BITS" | "$^WIDE_SYSTEM_CALLS" | "$^UNICODE" | "$^TAINT" | "$^UTF8LOCALE" | "$^RE_TRIE_MAXBUF" | "$^CHILD_ERROR_NATIVE" | "$^ENCODING" | "$^OPEN" | "$^RE_DEBUG_FLAGS" | "$^A" | "$^C" | "$^T" | "$^S" | "$^V" | "$^W" | "$^X" | "$^D" | "$^E" | "$^F" | "$^H" | "$^I" | "$^L" | "$^M" | "$^N" | "$^O" | "$^P" | "$^R" | "$^H" | "$!" | "$\"" | "$#" | "$$" | "$%" | "$&" | "$'" | "$(" | "$)" | "$*" | "$+" | "$," | "$_" | "$-" | "$`" | "$." | "$a" | "$/" | "$0" | "$:" | "$;" | "$<" | "$=" | "$>" | "$?" | "$@" | "$[" | "$]" | "$|" | "$^" | "$~"
    | PERL_SIGIL_SCALAR PERL_NUMBER

inner perl_array ::=
    perl_array_built_in
    | PERL_SIGIL_ARRAY PERL_BAREWORD ("::" PERL_BAREWORD) *

private perl_array_built_in ::= "@_" | "@!" | "@+" | "@-" | "@^H"

inner perl_hash ::=
    perl_hash_built_in
    | PERL_SIGIL_HASH PERL_BAREWORD ("::" PERL_BAREWORD) *

private perl_hash_built_in ::= "%!" | "%+" | "%-" | "%^H"

perl_glob ::= "*" PERL_BAREWORD ("::" PERL_BAREWORD) *